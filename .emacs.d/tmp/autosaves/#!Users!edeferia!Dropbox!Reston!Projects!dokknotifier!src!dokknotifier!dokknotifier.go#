
package main

import (
	"dokknotifier/config"
	"dokknotifier/mail"
	"dokknotifier/notification"
	"fmt"
	"github.com/yanatan16/mgoconf"
	"labix.org/v2/mgo"
	"runtime"
	"time"
	"log"
	"os"
)

type ProcessPayload struct {
	mgoSession *mgo.Session
	mailConfig config.MailgunConfig
}

var processPayload = ProcessPayload{}
var cycle = time.Minute * 1

func init() {
	processPayload.mgoSession = getMgoSession()
	processPayload.mailConfig = config.GetMailgunConfig()

	logsDirExists,_ := itemExists("logs")
	if !logsDirExists  {
		_ = os.Mkdir("logs", os.ModeDir)
	}
	
	f,_ := os.Create("logs/notifier.log")
	log.SetOutput(f)
	log.Printf("log initialized")
}

/*
  Runs foverever, checking for the valid notifications to be send every minute.
*/
func main() {

	defer processPayload.mgoSession.Close()

	report_ch := make(chan string)

	// main ticker loop
	for {
		select {
		case t := <-time.After(cycle):
			reportMem()
			go process(processPayload, t, report_ch)
		case s := <-report_ch:
			logme(s)
		}
	}
}

func reportMem() {
	var m runtime.MemStats
	runtime.ReadMemStats(&m)
	s := fmt.Sprintf("NextGC:%d, LastGC:%d, Alloc:%d, TotalAlloc:%d, Sys:%d, Lookups:%d, Mallocs:%d, Frees:%d",
		m.NextGC, m.LastGC, m.Alloc,
		m.TotalAlloc, m.Sys, m.Lookups, m.Mallocs, m.Frees)
	logme(s)
}

func logme(s string) {
	log.Printf(s)
}

func process(p ProcessPayload, t time.Time, report chan string) {

	report <- fmt.Sprintf("starting cycle for %s", t.Format(time.RFC3339))

	mgoSession := p.mgoSession.New()

	defer mgoSession.Close()
	
	notifications, err := notification.GetNotifications(mgoSession, report)

	if err != nil {
		report <- fmt.Sprintf("Error in process: %s", err)
	}

	processReminders(p.mailConfig, notifications, report)

	report <- fmt.Sprintf("ending cycle for %s", t.Format(time.RFC3339))
}

func processReminders(mailConf config.MailgunConfig, nots []notification.Notification, report chan string) {
	report <- fmt.Sprintf("there are %d notifications to process", len(nots))
	for i := 0; i < len(nots); i++ {
		go func(notif notification.Notification) {
			fmt.Println("Notification:", notif.Subject)
			_ = mail.SendNotification(mailConf, notif)
		}(nots[i])
	}
}

// Returns the initial session for the MongoDB server.
// IMPORTANT: Every goroutine should get a reference to this
// session and use New() to create a new one. The new session
// must be closed at the end of the goroutine.
func getMgoSession() *mgo.Session {
	cfg, err := mgoconf.Read("secrets/mongo.conf")
	if err != nil {
		panic(err)
	}
	session, err := cfg.Connect()
	if err != nil {
		panic(err)
	}
	return session
}


// exists returns whether the given file or directory exists or not
func itemExists(path string) (bool, error) {
	_, err := os.Stat(path)
	if err == nil { return true, nil }
	if os.IsNotExist(err) { return false, nil }
	return false, err
}