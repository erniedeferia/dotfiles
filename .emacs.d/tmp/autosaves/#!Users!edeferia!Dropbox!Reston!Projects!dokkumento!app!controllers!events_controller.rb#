# This was copied from another project (early Rails experimentation)
# and most of the code is fluff and should be removed.
class EventsController < AlexandriaCloudController
  include EventCommon


  # GET /events
  # GET /events.xml
  def index
    # full_calendar will hit the index method with query parameters
    # 'start' and 'end' in order to filter the results for the
    # appropriate month/week/day.  It should be possiblt to change
    # this to be starts_at and ends_at to match rails conventions.
    # I'll eventually do that to make the demo a little cleaner.
    logger.info "events#index case param #{params[:case]}"
    @organization = current_organization
    @events = Event.for_organization( current_user.member.organization )

    if has_context_part?('case') || !params[:case].nil?
      case_filter = get_context_part('case') if has_context_part?('case')
      case_filter ||= params[:case]
      @events = @events.for_case( case_filter ) #.paginate(:page => params[:page], :per_page => 5)
    end
    @events = @events.paginate(:page => params[:page], :per_page => 5)
    # @events = @events.after(params['start'])  if !params['start'].nil?
    # @events = @events.before(params['end'])  if !params['end'].nil?
  end

  # this will render the view to be displayed in the dashboard and which contains the events
  # for a selected day. date selection is provided via datepicker.
  # view rendered: summary.html.erb
  def summary
     @date = params.has_key?(:date) ?  params[:date] : Date.today.strftime('%m/%d/%Y')
     @events = Event.for_organization( current_user.member.organization ).for_day(@date)
     @events
     render :layout => false
  end

  # GET /events/1
  # GET /events/1.xml
  def show
    session[:return_to] = request.referrer
    @organization = current_organization
    @event = Event.includes(:reminder).find(params[:id])
  end

  # GET /events/new
  # GET /events/new.xml
  def new
    base_new
    @event.build_reminder
    @event.event_participants.build(:name => current_user.member.name, :email => current_user.member.email )
    # @event.event_participants.build
    respond_to do |format|
      format.html #new.html.erb
      format.js { render :partial => "form" }
    end
  end

  # GET /events/1/edit
  def edit
    base_edit
  end

  # POST /events
  # POST /events.xml
  def create
    base_create
    if @event.reminder.reminder_send_dt.nil?
       @event.reminder = nil
    end
    if( @event.save && !session[:return_to].nil? )
      redirect_to  session[:return_to]
    else
      redirect_to  organization_events_path(current_organization)
    end
  end

  # PUT /events/1
  # PUT /events/1.xml
  # PUT /events/1.js
  # when we drag an event on the calendar (from day to day on the month view, or stretching
  # it on the week or day view), this method will be called to update the values.
  # viva la REST!
  def update
    status = base_update
    if ( status )
      if( !session[:return_to].nil? )
        redirect_to session[:return_to]
      else
        redirect_to(@event, :notice => 'Event was successfully updated.')
      end
    else
      respond_to do |format|
        format.html { render :action => 'edit' }
      end
    end
  end

  # DELETE /events/1
  # DELETE /events/1.xml
  def destroy
    @event = Event.find(params[:id])
    @event.destroy

    respond_to do |format|
      format.html { redirect_to(organization_events_path(current_organization)) }
      format.xml  { head :ok }
    end
  end
end
