module DOKK
 class ProcessingStore

  attr_reader :staging_path

  WORKING_DIR = "#{Rails.root}/asset_store/processing"

  def initialize( document )
    @original_file_storage = (Rails.env == 'development') ? "filesystem" : "s3"
    @staging_path = build_staging_path(document)
    @original_filepath = document.original_file_name
    @escaped_filepath = (Rails.env == 'development') ? document.escaped_file_url : document.escaped_file_name
    ensure_folders
    Delayed::Worker.logger.info "[#{Time.now.to_s}] ProcessingStore#initialize #{self.inspect}"
  end

  def ensure_folders
    FileUtils.mkdir_p(WORKING_DIR) unless File.exists?(WORKING_DIR)
    FileUtils.mkdir_p(@staging_path) unless File.exists?(@staging_path)
  end

  #
  #  Retrieves the file associated with the document to the
  #  asset_store/processing location and returns the full 
  #  path.
  #
  #  Parameters:
  #    document: The Document model object from whcih to 
  #    retrieve the file for processing.
  #
  #  Returns:
  #    The full path to the staged file.
  def stage_document
    stage_file(@original_filepath, @escaped_filepath)
  end

 
  # Removes all files store in the asset processing store
  def cleanup
   Delayed::Worker.logger.info "Performing clean up of staging store files on location: #{@staging_path}"
   # Remove the files under the staging folder
   FileUtils.rm_rf("#{@staging_path}.", secure: true)
   # Remove the staing directory
   FileUtils.rm_rf("#{@staging_path}".chomp("/"), secure: true)
  end


   #
   # Returns the working path to store images and text files
   # for the document model passed in. 
   #
   # Note: that document.escaped_file_name returns a filesystem
   #       friendly name, but includes the extension, which we
   #       want to remove to create a directory path.
   #
   # Parameters:
   #  document: The document model object for which to define
   #  a working or staging path in the asset-store.
   #
   def build_staging_path ( document )
     puts 'STAGING_PATH: inside staging path'
     puts "STAGING_PATH: @original_file_storage = #{@original_file_storage}"
     filename = (@original_file_storage == 'filesystem') ? document.escaped_file_url : document.escaped_file_name
     puts "STAGING_PATH: filename = #{filename}, @original_file_storage = #{@original_file_storage}"
     basename = IO::File.basename( filename, IO::File.extname(filename) ) 
     WORKING_DIR + "/" + basename + "/"
   end

   def stage_file(filepath, escaped_file_path)
     Delayed::Worker.logger.info "[#{Time.now.to_s}] ProcessingStore#stage_file - <filepath>: #{filepath}"
     Delayed::Worker.logger.info "[#{Time.now.to_s}] ProcessingStore#stage_file - <escaped_file_path>: #{escaped_file_path}"
     dest = "#{@staging_path}#{escaped_file_path}"
     puts "P:processing staging_file dest #{dest}"
     IO::File.open( dest, "wb") do |f|
       f.write( get_file(filepath) )
     end
     Delayed::Worker.logger.info "[#{Time.now.to_s}] ProcessingStore#stage_file - storing file to #{dest}"
     dest
   end

   def get_file(filepath)
     Delayed::Worker.logger.info "[#{Time.now.to_s}] ProcessingStore#get_file <from> #{@original_file_storage}"
      (@original_file_storage == 'filesystem') ? get_from_fs(filepath) : get_from_s3(filepath)
   end

   # Returns a file stream for the specified file from MongoDB GridFS
   def get_from_gridfs ( filepath )
     Mongo::GridFileSystem.new( MongoConfig.database ).open( filepath, 'r' ) do |file|
        file.read
     end
   end

   # Returns a file stream for the specified file from the file system
   def get_from_fs( filepath )
      IO::File.open(filepath, 'r') do |f|
        f.read
      end
   end
 
   # Returns a file stream for the specified file from AWS S3
   def get_from_s3( filepath )
     s3 = RightAws::S3.new(Settings.aws_access_key, Settings.aws_secret_access_key)
     bucket = s3.bucket('dokkumento')
     bucket.get(filepath)
   end

 end
end
