const bPromise = require('bluebird');
const _ = require('lodash');
const moment = require('moment');
const crypto = require('crypto');

module.exports = function(db) {
  const permissionUtils = require('./permissions')(db);
  const userUtils = require('./users')(db);
  const pleadingUtils = require('./pleadings')(db);

  var fn = {

    _buildGetAllQuery: function(userID) {
      var query = db.select('*')
        .from('clients');

      if (userID) {
        query = query.whereIn('id', function() {
          this.select('clientID')
            .from('userLinks')
            .where('userID', '=', userID);
        });
      }

      return query;
    },

    generateHash: function() {
      return crypto.randomBytes(16).toString('hex');
    },

    getAll: function(userID) {
      var query = fn._buildGetAllQuery(userID);

      return query
        .then(function(clients) {
          var promises = [];
          var promise;
          var transform = fn.transformClientObject;

          if (userID) {
            transform = _.partialRight(transform, userID);
          }

          clients.forEach(function(client) {
            promise = transform(client)
              .then(function(transformedClient) {
                client = transformedClient;
              });

            promises.push(promise);
          });

          return bPromise.all(promises)
            .return(clients);
        });
    },

    getByID: function(clientID, userID) {
      userID = userID || false;

      return new bPromise(function(resolve, reject) {
        var query = db.select('*')
          .from('clients');

        if (userID) {
          query = query.whereIn('id', function() {
            this.select('clientID')
              .from('userLinks')
              .where('clientID', '=', clientID)
              .andWhere('userID', '=', userID);
          });
        } else {
          query = query.where('id', '=', clientID);
        }

        query = query
          .limit(1)
          .then(function(clients) {
            if (clients.length !== 1) {
              return reject(new Error('Could not retrieve client by ID'));
            }

            var client = clients[0];
            if (!userID) {
              return fn.transformClientObject(client);
            }

            return fn.transformClientObject(client, userID);
          })
          .then(resolve)
          .catch(reject);
      });
    },

    transformClientObjects: function(clients, userID) {
      var promises = [];
      var promise;

      clients.forEach(function(client) {
        promise = fn.transformClientObject(client, userID)
          .then(function(transformedClient) {
            client = transformedClient;
          });

        promises.push(promise);
      });

      return bPromise.all(promises)
        .return(clients);
    },

    transformClientObject: function(client, userID) {
      var promises = [];

      promises.push(fn._setupUpdatedByLinkForTransform(client));
      promises.push(fn._setupCaseNameForTransform(client));

      if (userID) {
        promises.push(fn._setupUserLinkForTransform(client, userID));
      }

      return bPromise.all(promises)
        .return(client);
    },

    _setupCaseNameForTransform: function(client) {
      var caseName = '';
      var clientFullName = '';
      var opposingFullName = '';

      if (client.clientEntity !== '') {
        clientFullName += client.clientEntity;
      } else {
        clientFullName += client.clientLastName + ', ' + client.clientFirstName;
      }

      if (client.opposingEntity !== '') {
        opposingFullName += client.opposingEntity;
      } else {
        opposingFullName += client.opposingLastName + ', '
          + client.opposingFirstName;
      }

      // Order should be: Plaintiff v Defendant
      if (client.clientRole === 'defendent') {
        client.caseName = opposingFullName + ' v. ' + clientFullName;
      } else {
        client.caseName = clientFullName + ' v. ' + opposingFullName;
      }

      return bPromise.resolve(client);
    },

    _setupUpdatedByLinkForTransform: function(client) {
      return userUtils.getByID(client.updatedBy)
        .then(function(user) {
          var fieldsToDisplay = [
            'id', 'username', 'firstName', 'lastName', 'companyName'
          ];
          client.updatedBy = _.pick(user, fieldsToDisplay);
        })
        .return(client);
    },

    _setupUserLinkForTransform: function(client, userID) {
      return permissionUtils.getRelationshipToClient(userID, client.id)
        .then(function(relationship) {
          var fieldsToDisplay = ['role', 'createdBy', 'createdAt'];
          client.userLink = _.pick(relationship, fieldsToDisplay);

          // update the "createdBy" property with a user
          return userUtils.getByID(relationship.createdBy);
        })
        .then(function(user) {
          var fieldsToDisplay = [
            'id', 'username', 'firstName', 'lastName', 'companyName'
          ];

          if (user) {
            client.userLink.createdBy = _.pick(user, fieldsToDisplay);
          }
        })
        .return(client);
    },

    create: function(userID, clientData) {
      return new bPromise(function(resolve, reject) {
        db.insert(clientData)
          .into('clients')
          .then(function(results) {
            if (results.length !== 1) {
              throw new Error('Database insertion failed');
            }

            return clientData.id = results[0];
          })
          .then(function(clientID) {
            return permissionUtils
                .addUserToClient(userID, clientID, 'account-owner', 0)
                .return(clientID);
          })
          .then(function(clientID) {
            return permissionUtils.getAccountAdmins(userID)
              .then(function(admins) {
                var promises = [];
                var promise;

                admins.forEach(function(admin) {
                  promise = permissionUtils
                    .addUserToClient(admin.id, clientID, 'account-admin',
                      userID);
                  promises.push(promise);
                });

                return bPromise.all(promises);
              });
          })
          .then(function() {
            return fn.transformClientObject(clientData, userID);
          })
          .then(resolve)
          .catch(reject);
      });
    },

    delete: function(clientID) {
      return fn.getByID(clientID)
        .then(function(client) {
          return bPromise.all([
            fn._removeAllPleadingsForClient(clientID),
            fn._removeAllUserLinksForClient(clientID),
            fn._removeClient(clientID)
          ]);
        });
    },

    _removeAllUserLinksForClient: function(clientID) {
      return permissionUtils.getUserLinksForClient(clientID)
        .then(function(links) {
          var promises = [];
          var promise;

          links.forEach(function(link) {
            promises.push(permissionUtils
              .removeUserFromClient(link.userID, link.clientID));
          });

          return bPromise.all(promises);
        });
    },

    _removeClient: function(clientID) {
      return db('clients')
        .where('id', '=', clientID)
        .del();
    },

    _removeAllPleadingsForClient: function(clientID) {
      return pleadingUtils.getAll(clientID)
        .then(function(pleadings) {
          var promises = [];
          var promise;

          pleadings.forEach(function(pleading) {
            promises.push(pleadingUtils.delete(pleading.id));
          });

          return bPromise.all(promises);
        });
    },

    update: function(clientID, updateData, userID) {
      updateData.updatedAt = parseInt(moment().format('X'), 10);
      updateData.updatedBy = userID;

      return new bPromise(function(resolve, reject) {
        fn.getByID(clientID, userID)
          .then(function(client) {
            // make sure this user can update this client
            if (client.userLink.role === 'client') {
              return reject(new Error('Invalid permissions'));
            }

            var skipKeys = ['id', 'userLink', 'createdAt', 'hash', 'caseName'];
            // now update the client record with the updateData
            Object.keys(updateData).forEach(function(key) {
              if (_.has(client, key) && skipKeys.indexOf(key) === -1) {
                client[key] = updateData[key];
              }
            });

            // make updateData match the newly added data
            updateData = _.omit(client, skipKeys);

            return db('clients')
              .where('id', '=', clientID)
              .update(updateData)
              .then(function() {
                return fn.transformClientObject(client, userID);
              })
              .then(resolve);

          })
          .catch(reject);
      });
    },

    search: function(filter, searchText, userID) {
      var query = fn._buildGetAllQuery(userID);
      var text = '%' + searchText + '%';

      if (!searchText || !searchText.length) {
        return query.orderBy('clientLastName', 'asc')
          .then(_.partialRight(fn.transformClientObjects, userID));
      }

      if (filter === 'clientName') {
        query = query.andWhere(function() {
          this.where('clientFirstName', 'like', text)
            .orWhere('clientLastName', 'like', text);
        });
      } else if (filter === 'caseNumber') {
        query = query.andWhere('caseNumber', 'like', text);
      } else if (filter === 'caseName') {
        query = query.andWhere(function() {
          this.where('clientFirstName', 'like', text)
            .orWhere('clientLastName', 'like', text)
            .orWhere('clientEntity', 'like', text)
            .orWhere('opposingFirstName', 'like', text)
            .orWhere('opposingLastName', 'like', text)
            .orWhere('opposingEntity', 'like', text);
        });
      } else if (filter === 'opposingAttorney') {
        query = query.andWhere('opposingAttorney', 'like', text);
      } else if (filter === 'clientAttorney') {
        query = query.andWhere('clientAttorney', 'like', text);
      } else if (filter === 'court') {
        query = query.andWhere('court', 'like', text);
      } else {
        query = query.andWhere(function() {
          this.where('clientFirstName', 'like', text)
            .orWhere('clientLastName', 'like', text)
            .orWhere('clientEntity', 'like', text)
            .orWhere('opposingFirstName', 'like', text)
            .orWhere('opposingLastName', 'like', text)
            .orWhere('opposingEntity', 'like', text)
            .orWhere('caseNumber', 'like', text)
            .orWhere('opposingAttorney', 'like', text)
            .orWhere('clientAttorney', 'like', text)
            .orWhere('court', 'like', text);
        });
      }

      return query.orderBy('clientLastName', 'asc')
        .then(_.partialRight(fn.transformClientObjects, userID));
    }

  };

  return fn;
};
