(ns hello-world.handler
  "Notes: (1) monger.json extends the chesire protocol to handle json serialization
   for MongoDB specific data structures, such as ObjectId and DBObject. This required
   version of 5.1.1 of chesire in the dependencies declarations.
   <paraedit> cheatsheet: http://www.emacswiki.org/emacs/PareditCheatsheet"
  (:use compojure.core
        ring.adapter.jetty
        clojure.contrib.def
        ring.util.response
        monger.operators
        [monger.collection :only [insert insert-batch]]
        [hiccup.core]
        ring.middleware.basic-authentication
        [ring.middleware.params]
        [ring.middleware.multipart-params]
        [hiccup.middleware :only (wrap-base-url)])
  (:require [compojure.route :as route]
            [compojure.handler :as handler]
            [compojure.response :as response]
            [clojure.java.io :as io]
            [monger.core :as mg]
            [monger.json]
            [monger.collection :as mc]
            [monger.gridfs :only [store-file make-input-file filename content-type metadata] :as mgfs]
            [ring.middleware.json :as middleware]
            [clojure.data.json :as cjson]
            [clj-json.core :as json])
  (:import [java.io File]
           [org.bson.types ObjectId]
           [com.mongodb DB WriteConcern])
    (:gen-class :extends javax.servlet.http.HttpServlet))


(def documents-database "dokkumento_api")
(def documents-collection "documents")

(defn- get-config
  "Loads configuration information from config.json"
  []
  (let [config-map (cjson/read-str (slurp "config.json"))  ]
    config-map
    )
  )

(defn init
  "Initializes the mongoDB connection loads configuration information."
  []
    (let [config-map (get-config)]
      (mg/connect! (mg/server-address (get config-map "database_server") (get config-map "database_port")) )
      (mg/set-db! (mg/get-db  (get config-map "database_name"))))
 )

(defn get-document
  "Returns the content of the document given its id.
   To test:
   curl -X GET   --header \"Authorization: Basic dGVzdDp0ZXN0\" --header \"Cache-Control:  max-age=0\"  http://localhost:3000/documents/52bcc74f30047a69c16e389b  -v
  "
  [id]
  (let  [document (mc/find-map-by-id "documents" (ObjectId. id))]
     (println "Retrieving document with id: " id " and has value:" (:_id document))
     (response document )
    )
  )

(defn get-documents
  "Returns the content of the document given its id.
   Note: The current implementation removes all keys with value of type
   bson.ObjectId because the json serializer (chesire) doesn't know how
   to hanxdle it. To test it with authentication, use this:
   curl -X GET   --header \"Authorization: Basic dGVzdDp0ZXN0\" --header \"Cache-Control:  max-age=0\"  http://localhost:3000/documents  -v
    Note: that the hex string is userid:password and this particular value is test:test
   "
  []
  (let [documents (mc/find-maps documents-collection {})]
   (println "get-documents. returnning" (count documents) "documnets..." )
   (response  documents ))
  )

(defn get-document-status
  "Returns the processing status of the requested document, by id."
  [id]
  (response {:status "OK"})  )

(defn delete-document
  "Deletes the processing data for the identified document, by id."
  [id]
  (response  {:result "OK", :deleted "true"}))


(defn- store-file-in-gridfs
  "Takes the multi-part parameter representing an uploaded file
   and stores it in MongoDB GridFS."
  [file]
  (mgfs/store-file (mgfs/make-input-file (:tempfile (:file file)))
              (mgfs/filename (:filename (:file file)) )
              (mgfs/metadata {:format "txt"})
              (mgfs/content-type (:filename (:file file))))
  )

(defn- store-file-metadata
  "Takes the multi-part parameter representing an uploaded file
   and stores its metadata in the [documents] collection."
  [file]
  (let [file-data (apply dissoc file [:file])]
    (println "Original file:" file)
    (println "File to store:" file-data)
    (insert "documents" (conj { :_id (ObjectId.) } file-data))  )
  )

(defn- store-file-in-db
  "Takes the multi-part parameter representing an uplaoded file
   and invokes the services of [store-file-metadata] and
   [store-file-in-gridfs] to store file metadata and its content
   in GridFS."
  [file]
  (store-file-metadata file)
  (store-file-in-gridfs file)
  )

(defn upload-file
  "This function supports multipart file upload. It can be tested
   with the following curl command:
   curl -X POST -i -F name=readme -F file=@README.md http://localhost:3000/documents/"
  [file]
  (let [file-name (file :filename)
        size (file :size)
        actual-file (file :tempfile)]
    (do
      (io/copy actual-file (File. (format "/Users/edeferia/test/%s" file-name)))
      (response {:status "Uplaoded", :saved_to file-name}))))

(defn authenticated?
  [user-name user-password]
  (println "authenticated? -> user-name: " user-name "password: " user-password)
  (and (= user-name "test") (= user-password "test")))

;;http://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api#rate-limiting
(defroutes main-routes
  (context "/documents" [] (defroutes doc-routes
          (POST "/" {params :params}
                (let [file (:file params)]
                  (println params)
                  (println file)
                  (store-file-in-db params)
                  (upload-file (:file params))))
           (GET "/" [] (get-documents))
           (context "/:id" [id] (defroutes doc-routes
                        (GET    "/" [] (get-document id))
                        (DELETE "/" [] (delete-document id))))))
        (route/not-found "Not Found"))


(def app
  (-> (handler/api main-routes)
      (wrap-basic-authentication authenticated?)
      (wrap-params)
      (wrap-multipart-params)
      (middleware/wrap-json-body)
      (middleware/wrap-json-response)))
