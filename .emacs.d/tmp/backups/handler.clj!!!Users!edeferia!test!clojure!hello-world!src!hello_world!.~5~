(ns hello-world.handler
  "Notes: (1) monger.json extends the chesire protocol to handle json serialization
   for MongoDB specific data structures, such as ObjectId and DBObject. This required
   version of 5.1.1 of chesire in the dependencies declarations.
   <paraedit> cheatsheet: http://www.emacswiki.org/emacs/PareditCheatsheet"
  (:use compojure.core
        ring.adapter.jetty
        clojure.contrib.def
        ;;clojure.contrib.condition
        ring.util.response
        monger.operators
        [monger.collection :only [insert insert-batch]]
        [hiccup.core]
        ring.middleware.basic-authentication
        [ring.middleware.params]
        [ring.middleware.multipart-params]
        [hiccup.middleware :only (wrap-base-url)])
  (:require [compojure.route :as route]
            [compojure.handler :as handler]
            [compojure.response :as response]
            [clojure.java.io :as io]
            [monger.core :as mg]
            [monger.json]
            [monger.collection :as mc]
            [monger.gridfs :only [store-file make-input-file filename content-type metadata] :as mgfs]
            [ring.middleware.json :as middleware]
            [clojure.data.json :as cjson]
            [clj-json.core :as json])
  (:import [java.io File]
           [org.bson.types ObjectId]
           [com.mongodb.MongoException]
           [java.net.ConnectException]
           [com.mongodb DB WriteConcern])
    (:gen-class :extends javax.servlet.http.HttpServlet))


(def documents-collection "documents")


(def error-codes
  {:invalid 400
      :not-found 404})



(defn- get-config
  "Loads configuration information from config.json"
  []
  (let [config-map (cjson/read-str (slurp "config.json"))  ]
    config-map
    )
  )

(defn init
  "Initializes the mongoDB connection loads configuration information."
  []
    (let [config-map (get-config)]
      (mg/connect! (mg/server-address (get config-map "database_server") (get config-map "database_port")) )
      (mg/set-db! (mg/get-db  (get config-map "database_name"))))
 )

(defn get-document
  "Returns the content of the document given its id.
   To test:
   curl -X GET   --header \"Authorization: Basic dGVzdDp0ZXN0\" --header \"Cache-Control:  max-age=0\"  http://localhost:3000/documents/52bcc74f30047a69c16e389b  -v
  "
  [id]
  (let  [document (mc/find-map-by-id "documents" (ObjectId. id))]
     ;;(println "Retrieving document with id: " id " and has value:" (:_id document))
     (response document )
    )
  )

(defn get-documents
  "Returns the content of the document given its id.
   Note: The current implementation removes all keys with value of type
   bson.ObjectId because the json serializer (chesire) doesn't know how
   to hanxdle it. To test it with authentication, use this:
   curl -X GET   --header \"Authorization: Basic dGVzdDp0ZXN0\" --header \"Cache-Control:  max-age=0\"  http://localhost:3000/documents  -v
    Note: that the hex string is userid:password and this particular value is test:test
   "
  []
  (let [documents (mc/find-maps documents-collection {})]
   ;;(println "get-documents. returnning" (count documents) "documnets..." )
   (response  documents ))
  )

(defn get-document-status
  "Returns the processing status of the requested document, by id."
  [id]
  (response {:status "OK"})  )

(defn delete-document
  "Deletes the processing data for the identified document, by id."
  [id]
  ;; first, delete from db.fs.file where {document_id: id}
  ;; then, delete from db.documents where {_id = id}
  (try
    (do
       (println (str "Deleting file with id: " id ) )
       (mc/update-by-id "documents" (ObjectId. id) {:deleted 1})
       ;; Notice the dot notation to reach into the nested metadata document
       (mgfs/remove {"metadata.document_id" (ObjectId. id) })
       (response  {:result "OK", :deleted "true"}) )
      (catch Exception e
        (let [{:keys [type message]} (meta e)]
          (println (str "Error detected:"  message))
          ;; TODO: need a function to return response after logging it and sending notification
          (response {"error" (str "Dokkumento API threw an error. Please inspect the following for more details. If this is an internal error, rest assure we're looking into it: " (.getMessage e)) } )))
    )
 )


(defn- store-file-in-gridfs
  "Takes the multi-part parameter representing an uploaded file
   and stores it in MongoDB GridFS."
  [file-and-metadata]
  (mgfs/store-file (mgfs/make-input-file (:tempfile (:file (:file-payload file-and-metadata))))
              (mgfs/filename (:filename (:file (:file-payload file-and-metadata))))
              (mgfs/metadata {:format "txt" :document_id (:document_id file-and-metadata)})
              (mgfs/content-type (:filename (:file (:file-payload file-and-metadata)))))
   (:document_id file-and-metadata)
  )

(defn- store-file-metadata
  "Takes the multi-part parameter representing an uploaded file
   and stores its metadata in the [documents] collection."
  [file]
  (let [file-data (apply dissoc file [:file]) new-id (ObjectId.) ]
    (insert "documents" (conj { :_id new-id } file-data))
    {:file-payload file, :document_id new-id}
    )
  )

(defn- store-file-in-db
  [file]
  "Takes the multi-part parameter representing an uplaoded file
   and invokes the services of [store-file-metadata] and
   [store-file-in-gridfs] to store file metadata and its content
   in GridFS. Note the use of comp to compose or pipe the call of
   three functions. First, store-file-metadata is invoked with
   the [file] parameter. The return of store-file-metadata, which
   is a two element map (see function), is then passed to the
   store-file-in-gridfs. The function store-file-in-gridfs
   returns the id of the newly stored document, which is then
   returned in the response as the :document-id element."
  (try
     (do ((comp  #(response {:status "OK", :document_id %})  store-file-in-gridfs   store-file-metadata) file) )
      (catch Exception e
        (let [{:keys [type message]} (meta e)]
          (println (str "Error detected:"  message))
          (response {"error" (str "Dokkumento API threw an error. Please inspect the following for more details. If this is an internal error, rest assure we're looking into it: " (.getMessage e)) } )))
    )
  )

(defn upload-file
  "This function supports multipart file upload. It can be tested
   with the following curl command:
   curl -X POST -i -F name=readme -F file=@README.md http://localhost:3000/documents/"
  [file]
  (let [file-name (file :filename)
        size (file :size)
        actual-file (file :tempfile)]
    (do
      (io/copy actual-file (File. (format "/Users/edeferia/test/%s" file-name)))
      (response {:status "Uplaoded", :saved_to file-name}))))

(defn authenticated?
  [user-name user-password]
  ;;(println "authenticated? -> user-name: " user-name "password: " user-password)
  (and (= user-name "test") (= user-password "test")))



;;http://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api#rate-limiting
(defroutes main-routes
  (context "/documents" [] (defroutes doc-routes
          (POST "/" {params :params}
                (let [file (:file params)]
                 ;; (println params)
                 ;; (println file)
                  (store-file-in-db params)))
           (GET "/" [] (get-documents))
           (context "/:id" [id] (defroutes doc-routes
                        (GET    "/" [] (get-document id))
                        (DELETE "/" [] (delete-document id))))))
        (route/not-found "Not Found"))


;; This DID NOT work
;; I was attempting to wrap the routes in an exception handling form.
(defn wrap-error-handling [req]
  (fn [req]
    (try
      (do (println "executing wrap-error-handling")  (main-routes req) )
      (catch java.net.SocketException  socketEx
        (let [{:keys [type message]} (meta socketEx)]
          (println (str "Socket detected:"  message))
          (response {"error" message} (error-codes type))))
      (catch java.net.ConnectException  connectEx
        (let [{:keys [type message]} (meta connectEx)]
          (println (str "Socket detected:"  message))
          (response {"error" message} (error-codes type))))
       #_(catch com.mongodb.MongoException mongoEx
        (let [{:keys [type message]} (meta mongoEx)]
          (println (str "Error detected:"  message))
          (response {"error" message} (error-codes type))))
      (catch Exception e
        (let [{:keys [type message]} (meta e)]
          (println (str "Error detected:"  message))
          (response {"error" message} (error-codes type))))
      )))

(def app
  (-> (handler/api main-routes)
      (wrap-basic-authentication authenticated?)
      (wrap-params)
      (wrap-multipart-params)
      (middleware/wrap-json-body)
      (middleware/wrap-json-response)
      ))
